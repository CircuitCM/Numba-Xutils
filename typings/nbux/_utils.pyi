

import numpy as np
from collections.abc import Callable, Sequence
from types import NoneType
from typing import Any, Callable, Sequence
from numba.extending import intrinsic

_N = ...
unroll = ...
CSeq = tuple | list
def njit_no_parallelperf_warn(**njit_kwargs): # -> Callable[..., Any]:
    
    ...

def rg_no_parallelperf_warn(rrg): # -> Callable[..., Any]:
    ...

_fm = ...
_fm = ...
_erm = ...
_dft = ...
jit_s = ...
jit_sn = ...
jit_sc = ...
jit_scn = ...
jit_si = ...
jit_sci = ...
jit_scin = ...
jit_p = ...
jit_pn = ...
jit_pc = ...
jit_pcn = ...
jit_pi = ...
jit_pci = ...
jt = ...
jtc = ...
jtn = ...
jtnc = ...
jti = ...
jtic = ...
jtp = ...
jtp_s = ...
jtpc = ...
jtpc_s = ...
jtpn = ...
jtpn_s = ...
jtpnc = ...
jtpnc_s = ...
_rg = ...
rg = ...
rgc = ...
rgi = ...
rgic = ...
rgp = ...
rgp_s = ...
rgpc = ...
rgpc_s = ...
ovs = ...
ovsi = ...
ovsc = ...
ovsic = ...
ovp = ...
ovpc = ...
fb_ = ...
def compiletime_parallelswitch(): # -> None:
    ...

@intrinsic
def stack_empty_impl(typingctx, size, dtype): # -> tuple[Any, Callable[..., Any]]:
    
    ...

def stack_empty(size, shape, dtype):
    
    ...

@jtc
def stack_empty_(size, shape, dtype):
    
    ...

@intrinsic
def nb_val_ptr(typingctx, data): # -> tuple[Any, Callable[..., Any]]:
    
    ...

@intrinsic
def nb_ptr_val(typingctx, data): # -> tuple[Any, Callable[..., Any]]:
    
    ...

@intrinsic
def nb_array_ptr(typingctx, arr_typ): # -> tuple[Any, Callable[..., Any]]:
    
    ...

@jtic
def buffer_nelems_andp(arr: np.ndarray) -> tuple[int, Sequence]:
    
    ...

def ri64(rd: float): # -> int:
    ...

ri32 = ...
@rgic
def display_round(f, m=..., s=...):
    
    ...

def type_ref(arg): # -> type[Any]:
    
    ...

def if_val_cast(typ, val):
    ...

Op = Callable | NoneType | CSeq
def op_call(call_op: Op, defr=...): # -> bool | tuple[Any, ...] | list[Any] | None:
    
    ...

def op_call_args(call_op: Op, args: CSeq | Any = ..., defr=...): # -> None:
    
    ...

def op_args(call_op: Op, args: CSeq | Any = ..., defr=...): # -> None:
    
    ...

@rgc
def aligned_buffer(n_bytes: int, align: int = ...) -> np.ndarray:
    
    ...

def prim_info(dt, field): # -> complex | bool | None:
    
    ...

np_tinfo = ...
@jtic
def placerange(r, start=..., step=...): # -> None:
    
    ...

@rgi
def swap(x, i, j): # -> None:
    
    ...

def force_const(val):
    
    ...

def run_py(func, *args, **kwargs):
    
    ...

def run_numba(func, *args, verbose=..., **kwargs):
    
    ...

def ir_force_separate_pl(sync_impl, pl_impl): # -> Callable[..., Any]:
    
    ...

def l_1_0(x, i1=...):
    ...

def l_1_1(x, i1=...):
    ...

def l_1_2(x, i1=...):
    ...

def l_12_0(x, i1=..., i2=...):
    ...

def l_21_0(x, i1=..., i2=...):
    ...

def l_12_d(x, i1=..., i2=..., d=...):
    ...

_verbs = ...
